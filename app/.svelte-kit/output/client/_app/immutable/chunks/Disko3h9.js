import{d as a,a_ as u,k as v,ae as l,af as E}from"./Cy0nnqwK.js";const p="ws://localhost:8000";class g extends Event{message;constructor(e){super("message"),this.message=e}}class m extends Event{account;constructor(e){super("auth"),this.account=e}}class f extends EventTarget{#e;id;constructor(e,t){super(),this.#e=e,this.id=t}async reply(e){return new Promise((t,s)=>{e?.throwIfAborted();const n=o=>{o.message.id===this.id&&(t(o.message),this.#e.removeEventListener("message",n),e?.removeEventListener("abort",i))},i=()=>{s(e.reason),this.#e.removeEventListener("message",n)};this.#e.addEventListener("message",n),e?.addEventListener("abort",i)})}$then(e){a(()=>{const t=new AbortController;return this.reply(t.signal).then(s=>{e(s)},s=>{if(s!=="unmounted")throw s}),()=>t.abort("unmounted")})}}class h extends EventTarget{addEventListener(e,t,s){super.addEventListener(e,t,s)}removeEventListener(e,t,s){super.removeEventListener(e,t,s)}$on(e,t,s){a(()=>{let n;function i(o){n?.(),n=u(()=>t.call(this,o))}return this.addEventListener(e,i,s),()=>{n?.(),this.removeEventListener(e,i,s)}})}}class L extends Event{message;constructor(e){super("next"),this.message=e}}class w extends h{#e;#t;id;constructor(e,t){super(),this.#e=e,this.id=t,this.#t=s=>{s.message.id===this.id&&this.dispatchEvent(new L(s.message))},this.#e.addEventListener("message",this.#t)}unsubscribe(){this.#e.unsubscribe(this.id),this.#e.removeEventListener("message",this.#t)}}class c extends h{static PROTOCOL=["v1.cartography.app"];#e;#t;constructor(e){super(),this.#t=e,this.#e=new WebSocket(this.#t,c.PROTOCOL),this.#n()}#n(){this.#e.addEventListener("open",n=>{console.log("Socket opened",n),this.dispatchEvent(new Event("open"))}),this.#e.addEventListener("message",n=>{const i=n.data;typeof i!="string"&&(this.#e.close(1003,"Only text messages are supported"),this.dispatchEvent(new Event("error")));try{const o=JSON.parse(i);this.dispatchEvent(new g(o))}catch{this.#e.close(4e3,"Invalid JSON received"),this.dispatchEvent(new Event("error"))}});const e=()=>{this.#e.removeEventListener("error",t),this.#e.removeEventListener("close",s),this.#e=new WebSocket(this.#t,c.PROTOCOL),this.#n()},t=n=>{console.error("Socket error",n),this.dispatchEvent(new Event("error",n)),e()},s=n=>{console.log("Socket closed",n),this.dispatchEvent(new CloseEvent("close",n)),n.wasClean||e()};this.#e.addEventListener("error",t),this.#e.addEventListener("close",s)}#s(e,t={},s=window.crypto.randomUUID()){return this.#e.send(JSON.stringify({type:e,data:t,id:s})),new f(this,s)}auth(e){this.#s("auth",e).reply().then(t=>{this.dispatchEvent(new m(t.data.account))})}getFields(){return this.#s("get_fields")}getField(e){return this.#s("get_field",{field_id:e})}unsubscribe(e){this.#s("unsubscribe",{},e)}subscribe(e){const t=window.crypto.randomUUID();return this.#s("subscribe",{channel:e},t),new w(this,t)}close(e,t){this.#e.close(e,t)}}const d=Symbol("Socket");function k(){return E(d).socket}function x(){let r;v(()=>(r=new c(`${p}/websocket`),r.addEventListener("open",()=>{r.auth({id:"foxfriends"})}),()=>r.close())),l(d,{get socket(){return r}})}export{k as g,x as p};
